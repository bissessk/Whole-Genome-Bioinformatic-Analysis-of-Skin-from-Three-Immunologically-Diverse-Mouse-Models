---
title: "DE Seq Analysis of GSE119202"
author: "Kieran Bissessar"
date: "12/5/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1 Read in Data

read in files
```{r}
GSM3360685_C57  =  read.table("GSM3360685_C57-1.txt", header = T, sep="\t")
GSM3360686_C57  =  read.table("GSM3360686_C57-2.txt", header = T, sep="\t")
GSM3360687_C57  =  read.table("GSM3360687_C57-3.txt", header = T, sep="\t")
GSM3360688_KO   =  read.table("GSM3360688_KO-1.txt", header = T, sep="\t")
GSM3360689_KO   =  read.table("GSM3360689_KO-2.txt", header = T, sep="\t")
GSM3360690_KO   =  read.table("GSM3360690_KO-3.txt", header = T, sep="\t")
GSM3360691_Balb =  read.table("GSM3360691_Balb-1.txt", header = T, sep="\t")
GSM3360692_Balb =  read.table("GSM3360692_Balb-2.txt", header = T, sep="\t")
GSM3360693_Balb =  read.table("GSM3360693_Balb-3.txt", header = T, sep="\t")
```

GSM3360685_C57 was duplicated for some reason
```{r}
GSM3360685_C57=GSM3360685_C57[1:49585,]
```

Then a data frame was contructed using the unique gene counts
```{r}
GSE119202.RAW = data.frame("GSM3360685_C57"  =  as.numeric(GSM3360685_C57$Unique.gene.reads),
                           "GSM3360686_C57"  =  as.numeric(GSM3360686_C57$Unique.gene.reads),
                           "GSM3360687_C57"  =  as.numeric(GSM3360687_C57$Unique.gene.reads),
                           "GSM3360688_KO"   =  as.numeric(GSM3360688_KO$Unique.gene.reads),
                           "GSM3360689_KO"   =  as.numeric(GSM3360689_KO$Unique.gene.reads),
                           "GSM3360690_KO"   =  as.numeric(GSM3360690_KO$Unique.gene.reads),
                           "GSM3360691_Balb" =  as.numeric(GSM3360691_Balb$Unique.gene.reads),
                           "GSM3360692_Balb" =  as.numeric(GSM3360692_Balb$Unique.gene.reads),
                           "GSM3360693_Balb" =  as.numeric(GSM3360693_Balb$Unique.gene.reads),
                           row.names = GSM3360685_C57$Gene.ID)

head(GSE119202.RAW)
```

# 2 Prepare for the Creation of our DESeq Dataset

There are three conditions:
  1. C57(control)
  2. KO
  3. Balb
  
With these conditions, factors will be set and a column dataframe can be constructed.
```{r}
condition = as.factor(c(rep("C57",3),rep("KO",3),rep("Balb",3)))
column_data = data.frame(condition, row.names = colnames(GSE119202.RAW))
print(column_data)

```


# 3 Create DESeq Dataset

Now we can begin creating a DESeq Dataset.
```{r}
library(DESeq2)

cds = DESeqDataSetFromMatrix(countData = GSE119202.RAW,
                             colData = column_data,
                             design = ~ condition )
print(cds)
```

# 4 Analyze DeSeq Dataset object

It is useful to filter out low count genes in order to minimize bias.
```{r}
keep = rowSums(counts(cds)) >= 10 # keep is a temp
cds = cds[keep,]
print(cds)
```

30803 genes were filtered out (about 62%).

Now that we filtered by readcount, we can use the DESeq wrapper function. This function estimates size factors (scaling factors used in DESeq2 normalization), dispersions for each gene, and conducts a Wald Test of DGE using the normalized count data.

```{r}
cds = DESeq(cds)
```

To oberve our dispersion estimates,

```{r fig.align="center"}
plotDispEsts(object = cds,
             main = "Gene Estimate Dispersion Plot",
             genecol = "black",
             fitcol = "brown",
             finalcol = "gray",
             legend = TRUE)
```

The fit type was chosen to be `local` and this is not the most ideal plot.

A common first task to analyzing DGE data is to cluster samples hierarchically and use Principal Components Analysis (PCA). This can help provide an early indication of the distances between sample gene expression profiles and detect possible batch effects.

Developers of DESeq2 recommend that before clustering of samples a “regularized log” or “variance stabilizing” transformation should be performed on the normalized counts. These transformations are for clustering/machine learning applications only and are not used in the statistical analysis of DGE.

Hierarchical Sample Clustering

```{r fig.align="center"}
rld = rlog(cds)
dists = dist(t(assay(rld)))
plot(hclust(dists)) # one of the control seems off
```

PCA
```{r fig.align="center"}
plotPCA(object = rld) # also shows one of the control being off
#batch effect? were they run on the same lane?
```

GSM3360685_C57 is a bit off. Batch effect?
This was also the sample that was three times longer the rest and shortened.

Since its whack lets remove it

## Rectifying DESeq Dataset

```{r}
#set wonky control sample to null
GSE119202.RAW$GSM3360685_C57 = NULL
head(GSE119202.RAW)
```

```{r}
condition = as.factor(c(rep("C57",2),rep("KO",3),rep("Balb",3)))
column_data = data.frame(condition, row.names = colnames(GSE119202.RAW))
print(column_data)

```

```{r}
cds = DESeqDataSetFromMatrix(countData = GSE119202.RAW,
                             colData = column_data,
                             design = ~ condition )
print(cds)
```

```{r}
#filter out low count genes to minimize bias
keep = rowSums(counts(cds)) >= 10 # keep is a temp
cds = cds[keep,]
print(cds)
colnames(cds)
```

```{r}
#DESeq wrapper function to normalize etc.
cds = DESeq(cds)
```

```{r fig.align="center"}
# see how our dispersions look

plotDispEsts(object = cds,
             main = "Gene Estimate Dispersion Plot - Rectified",
             genecol = "black",
             fitcol = "red",
             legend = TRUE)

rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col = 
"grey")
```

Our Rectified Gene Estimate Dispersion Plot looks much better!

# 5 Creating a DESeq Results Object for each Comparison

Next DESeq results objects were created. Using the contrast parameter, the control (C57) was compared with the knockout variant, the control (C57) was compared with the Balb variant, and the KO variant was compared with the Balb variant.

```{r}
expgenes_C57_KO_res = results(cds, contrast = c("condition","C57","KO"))
head(expgenes_C57_KO_res)
mcols(expgenes_C57_KO_res)$description

expgenes_C57_Balb_res = results(cds, contrast = c("condition","C57","Balb"))
head(expgenes_C57_KO_res)
mcols(expgenes_C57_Balb_res)$description

expgenes_KO_Balb_res = results(cds, contrast = c("condition","KO", "Balb"))
head(expgenes_C57_KO_res)
mcols(expgenes_KO_Balb_res )$description
```

Next, MA plots were constructed for each comparison to visualize the difference in log fold changes across the entire dataset. Because DESEq2 log2 fold-change estimates are frequently over-estimated particularly for low expression genes, to obtain better estimates of the log2 fold-change, DESeq2 recommends “shrinking” the raw estimates in the output table above with the lfcShrink() function to extract results from a DESeqDataSet object with shrunken log2 fold-change estimates. Note, this function is essentially the same as the “results” function, except that it returns shrunken log2 fold-change estimates.

```{r fig.align="center"}
plotMA(expgenes_C57_KO_res,
       ylim = c(-6,6),
       main = "MA Plot : C57BL/6 vs IL – 6 KO")


expgenes_C57_KO_res.shrunk = lfcShrink(cds, contrast = c("condition","C57","KO") )
plotMA(expgenes_C57_KO_res.shrunk,
       ylim = c(-6,6),
       main = "MA Plot : C57BL/6 vs IL – 6 KO - shrunk")
```

```{r fig.align="center"}
plotMA(expgenes_C57_Balb_res,
       ylim = c(-6,6),
       main = "MA Plot : C57BL/6 vs BALB/c")


expgenes_C57_Balb_res.shrunk = lfcShrink(cds, contrast = c("condition","C57","Balb") )
plotMA(expgenes_C57_Balb_res.shrunk,
       ylim = c(-6,6),
       main = "MA Plot : C57BL/6 vs BALB/c - shrunk")
```

```{r fig.align="center"}
plotMA(expgenes_KO_Balb_res,
       ylim = c(-6,6),
       main = "MA Plot : IL – 6 KO vs BALB/c")

expgenes_KO_Balb_res.shrunk = lfcShrink(cds, contrast = c("condition","KO","Balb") )
plotMA(expgenes_KO_Balb_res.shrunk,
       ylim = c(-6,6),
       main = "MA Plot : IL – 6 KO vs BALB/c - shrunk")
```

# 6 Determining Differentially Expressed Genes

Next, to begin determining which genes are differnentially expressed, we will sort our results list according to the adjusted pvalue (not the raw pvalue bc the dataset is very large). Then we will filter out genes with an adjusted pvalue more than 0.05.

Before we do this, we should remove results that have any NAs in them.
```{r}
expgenes_C57_KO_res.shrunk = expgenes_C57_KO_res.shrunk[complete.cases(expgenes_C57_KO_res.shrunk),]
expgenes_C57_Balb_res.shrunk = expgenes_C57_Balb_res.shrunk[complete.cases(expgenes_C57_Balb_res.shrunk),]
expgenes_KO_Balb_res.shrunk = expgenes_KO_Balb_res.shrunk[complete.cases(expgenes_KO_Balb_res.shrunk),]
```

Now we can sort by `padj`
```{r}
c57_KO_res_sh_ordered = expgenes_C57_KO_res.shrunk[order(expgenes_C57_KO_res.shrunk$padj),]
c57_Balb_res_sh_ordered = expgenes_C57_Balb_res.shrunk[order(expgenes_C57_Balb_res.shrunk$padj),]
KO_Balb_res_sh_ordered = expgenes_KO_Balb_res.shrunk[order(expgenes_KO_Balb_res.shrunk$padj),]
```

Once sorted, we can remove genes with a padj > 0.05.
```{r}
c57_KO_res_fdr = c57_KO_res_sh_ordered[c57_KO_res_sh_ordered$padj<=0.05,]
c57_Balb_res_fdr = c57_Balb_res_sh_ordered[c57_Balb_res_sh_ordered$padj<=0.05,]
KO_Balb_res_fdr = KO_Balb_res_sh_ordered[KO_Balb_res_sh_ordered$padj<=0.05,]
```

The log2(fold-change) is the log-ratio of a gene's or a transcript's expression values in two different conditions. By filtering out genes with a log2fold between 1 and -1, we should be left with the genes that are most likely to be differentially expressed. 
```{r}
c57_KO_res_fdr_lc_cut_1 = c57_KO_res_fdr[c57_KO_res_fdr$log2FoldChange>=1,]
c57_KO_res_fdr_lc_cut_2 = c57_KO_res_fdr[c57_KO_res_fdr$log2FoldChange<= -1,]

c57_KO_diff_exp = c(row.names(c57_KO_res_fdr_lc_cut_1), row.names(c57_KO_res_fdr_lc_cut_2)) #list of diff exp genes
summary(c57_KO_diff_exp) # 3683 diff exp genes
```

```{r}
c57_Balb_res_fdr_lc_cut_1 = c57_Balb_res_fdr[c57_Balb_res_fdr$log2FoldChange>=1,]
c57_Balb_res_fdr_lc_cut_2 = c57_Balb_res_fdr[c57_Balb_res_fdr$log2FoldChange<= -1,]

c57_Balb_diff_exp = c(row.names(c57_Balb_res_fdr_lc_cut_1), row.names(c57_Balb_res_fdr_lc_cut_2)) #list of diff exp genes
summary(c57_Balb_diff_exp) # 499 diff exp genes
```
```{r}
KO_Balb_res_fdr_lc_cut_1 = KO_Balb_res_fdr[KO_Balb_res_fdr$log2FoldChange>=1,]
KO_Balb_res_fdr_lc_cut_2 = KO_Balb_res_fdr[KO_Balb_res_fdr$log2FoldChange<= -1,]

KO_Balb_diff_exp = c(row.names(KO_Balb_res_fdr_lc_cut_1), row.names(KO_Balb_res_fdr_lc_cut_2)) #list of diff exp genes
summary(KO_Balb_diff_exp) #1468 diff exp genes
```
## Volcano Plots

Volcano Plots are a good way to visualize differentially expressed genes.

```{r}
par(mar=c(5,5,5,5), cex=1.0, cex.main=1.4, cex.axis=1.4, cex.lab=1.4)

topT1 <- as.data.frame(c57_KO_res_sh_ordered)

#Adjusted P values (FDR Q values)
with(topT1, plot(log2FoldChange, -log10(padj), pch=20, main="Volcano plot C57BL/6 vs IL-6 KO", cex=1.0, xlab=bquote(~Log[2]~fold~change), ylab=bquote(~-log[10]~Q~value)))

with(subset(topT1, padj<0.05 & abs(log2FoldChange)>1), points(log2FoldChange, -log10(padj), pch=20, col="red", cex=0.5))

#Add lines for absolute FC>2 and P-value cut-off at FDR Q<0.05
abline(v=0, col="black", lty=3, lwd=1.0)
abline(v=-1, col="black", lty=4, lwd=2.0)
abline(v=1, col="black", lty=4, lwd=2.0)
abline(h=-log10(max(topT1$pvalue[topT1$padj<0.05], na.rm=TRUE)), col="black", lty=4, lwd=2.0)


##########


par(mar=c(5,5,5,5), cex=1.0, cex.main=1.4, cex.axis=1.4, cex.lab=1.4)

topT2 <- as.data.frame(c57_Balb_res_sh_ordered)

#Adjusted P values (FDR Q values)
with(topT2, plot(log2FoldChange, -log10(padj), pch=20, main="Volcano plot C57BL/6 vs BALB/c", cex=1.0, xlab=bquote(~Log[2]~fold~change), ylab=bquote(~-log[10]~Q~value)))

with(subset(topT2, padj<0.05 & abs(log2FoldChange)>1), points(log2FoldChange, -log10(padj), pch=20, col="red", cex=0.5))

#Add lines for absolute FC>2 and P-value cut-off at FDR Q<0.05
abline(v=0, col="black", lty=3, lwd=1.0)
abline(v=-1, col="black", lty=4, lwd=2.0)
abline(v=1, col="black", lty=4, lwd=2.0)
abline(h=-log10(max(topT2$pvalue[topT2$padj<0.05], na.rm=TRUE)), col="black", lty=4, lwd=2.0)


##########


par(mar=c(5,5,5,5), cex=1.0, cex.main=1.4, cex.axis=1.4, cex.lab=1.4)

topT3 <- as.data.frame(KO_Balb_res_sh_ordered)

#Adjusted P values (FDR Q values)
with(topT3, plot(log2FoldChange, -log10(padj), pch=20, main="Volcano plot IL - 6 KO vs BALB/c", cex=1.0, xlab=bquote(~Log[2]~fold~change), ylab=bquote(~-log[10]~Q~value)))

with(subset(topT3, padj<0.05 & abs(log2FoldChange)>1), points(log2FoldChange, -log10(padj), pch=20, col="red", cex=0.5))

#Add lines for absolute FC>2 and P-value cut-off at FDR Q<0.05
abline(v=0, col="black", lty=3, lwd=1.0)
abline(v=-1, col="black", lty=4, lwd=2.0)
abline(v=1, col="black", lty=4, lwd=2.0)
abline(h=-log10(max(topT3$pvalue[topT3$padj<0.05], na.rm=TRUE)), col="black", lty=4, lwd=2.0)


```
# 7 Clustering

Clustering gene expression data allows us to identify substructures in the data and identify groups of genes that behave similarly.

To begin clustering, normalized values need to be retreived
```{r}
rawcounts.matrix = counts(cds, normalized = F)
normalizedcounts.matrix = counts(cds,normalized=T)
head(normalizedcounts.matrix)
```

Now we are going to subset our normalized counts matrix for each result object
```{r}
diffexp_norm_C57_KO = subset(normalizedcounts.matrix, rownames(normalizedcounts.matrix) %in% c57_KO_diff_exp)
diffexp_norm_C57_Balb = subset(normalizedcounts.matrix, rownames(normalizedcounts.matrix) %in% c57_Balb_diff_exp)
diffexp_norm_KO_Balb = subset(normalizedcounts.matrix, rownames(normalizedcounts.matrix) %in% KO_Balb_diff_exp)
```

Then we will perform a peason correlation to help get the distance objects needed to perform clustering.
```{r}
diffexp_norm_C57_KO.cor = cor(t(diffexp_norm_C57_KO), method = "pearson")
diffexp_norm_C57_Balb.cor = cor(t(diffexp_norm_C57_Balb), method = "pearson")
diffexp_norm_KO_Balb.cor = cor(t(diffexp_norm_KO_Balb), method = "pearson")
```

With our correlations we can create distance objects
```{r}
diffexp_C57_KO.dist = as.dist(1 - diffexp_norm_C57_KO.cor)
diffexp_C57_Balb.dist = as.dist(1 - diffexp_norm_C57_Balb.cor)
diffexp_KO_Balb.dist = as.dist(1 - diffexp_norm_KO_Balb.cor)
```

Now that we have distance objects, we can begin clustering
```{r}
diffexp_C57_KO.clust = hclust(diffexp_C57_KO.dist, method = "average")
diffexp_C57_Balb.clust = hclust(diffexp_C57_Balb.dist, method = "average")
diffexp_KO_Balb.clust = hclust(diffexp_KO_Balb.dist, method = "average")
```

Plotting the clusters may help visualize commonalitys in the differentially expressed genes
```{r fig.align="center"}
plot(diffexp_C57_KO.clust) # seems like 2 main groups
plot(diffexp_C57_Balb.clust)# also seems like 2 main groups but the right side is more split
plot(diffexp_KO_Balb.clust) # seems like 2 main groups
```


Each cluster will be split into 2 main groups
```{r}
diffexp_C57_KO.clust.groups = cutree(diffexp_C57_KO.clust, k = 2)
diffexp_C57_Balb.clust.groups = cutree(diffexp_C57_Balb.clust, k = 2)
diffexp_KO_Balb.clust.groups = cutree(diffexp_KO_Balb.clust, k = 2)
```

To determine how many genes are in each group,
```{r}
table(diffexp_C57_KO.clust.groups) # 1958 1725 
table(diffexp_C57_Balb.clust.groups) # 386 113 
table(diffexp_KO_Balb.clust.groups) # 630 838 
```

Now we will subset our clusters to get vectors of the Gene IDs in each cluster group.

```{r}
cluster1.1genes = diffexp_norm_C57_KO[diffexp_C57_KO.clust.groups == 1,]
group1.1=rownames(cluster1.1genes)
cluster1.2genes = diffexp_norm_C57_KO[diffexp_C57_KO.clust.groups == 2,]
group1.2=rownames(cluster1.2genes)
# cluster1.3genes = diffexp_norm_C57_KO[diffexp_C57_KO.clust.groups == 3,]
# group1.3=rownames(cluster1.1genes)

cluster2.1genes = diffexp_norm_C57_Balb[diffexp_C57_Balb.clust.groups==1,]
group2.1=rownames(cluster2.1genes)
cluster2.2genes = diffexp_norm_C57_Balb[diffexp_C57_Balb.clust.groups==2,]
group2.2=rownames(cluster2.2genes)
# cluster2.3genes = diffexp_norm_C57_Balb[diffexp_C57_Balb.clust.groups==3,]
# group2.3=rownames(cluster2.1genes)

cluster3.1genes = diffexp_norm_KO_Balb[diffexp_KO_Balb.clust.groups==1,]
group3.1=rownames(cluster3.1genes)
cluster3.2genes = diffexp_norm_KO_Balb[diffexp_KO_Balb.clust.groups==2,]
group3.2=rownames(cluster3.2genes)
# cluster3.3genes = diffexp_norm_KO_Balb[diffexp_KO_Balb.clust.groups==3,]
# group3.3=rownames(cluster3.1genes)

```

# Heatmaps

A common method of visualising gene expression data is to display it as a heatmap. The color and intensity of the boxes is used to represent _changes_ (not absolute values) of gene expression.

To contruct Heatmaps the `gplots` library needs to be called and a correlation function needs to be defined (since we want to use a Pearson Correlation)

```{r}
library(gplots)

corfun = function(x){
        return( as.dist(1-cor(t(x), method = 'pearson')))
}
```

`heatmap.2` was used to make the heat maps for each cluster group.

```{r fig.align="center"}

my_palette <- colorRampPalette(c("red","black", "green"), space = "rgb")


heatmap.2(as.matrix(cluster1.1genes),
          distfun = corfun,
          scale="row",
          Colv = F,
          dendrogram = "row",
          trace = "none",
          main = "Cluster C57BL/6 vs IL – 6 KO
          Group 1 Heat Map",
          keysize = 1.5,
          symkey = T,
          col = my_palette,
          cexRow=1,
          cexCol=1,
          margins = c(7,11),
          srtCol = 45)

heatmap.2(as.matrix(cluster1.2genes),
          distfun = corfun,
          scale="row",
          Colv = F,
          dendrogram = "row",
          trace = "none",
          main = "Cluster C57BL/6 vs IL – 6 KO 
          Group 2 Heat Map",
          keysize = 1.5,
          symkey = T,
          col = my_palette,
          cexRow=1,
          cexCol=1,
          margins = c(7,11),
          srtCol = 45)

# heatmap.2(as.matrix(cluster1.3genes),
#           distfun = corfun,
#           scale="row",
#           Colv = F,
#           dendrogram = "row",
#           trace = "none",
#           main = "Cluster 1.3 Heat Map",
#           keysize = 1.5,
#           symkey = T,
#           col = my_palette,
#           cexRow=1,
#           cexCol=1,
#           margins = c(7,11),
#           srtCol = 45)



heatmap.2(as.matrix(cluster2.1genes),
          distfun = corfun,
          scale="row",
          Colv = F,
          dendrogram = "row",
          trace = "none",
          main = "Cluster C57BL/6 vs BALB/c 
          Group 1 Heat Map",
          keysize = 1.5,
          symkey = T,
          col = my_palette,
          cexRow=1,
          cexCol=1,
          margins = c(7,11),
          srtCol = 45)

heatmap.2(as.matrix(cluster2.2genes),
          distfun = corfun,
          scale="row",
          Colv = F,
          dendrogram = "row",
          trace = "none",
          main = "Cluster C57BL/6 vs BALB/c 
          Group 2 Heat Map",
          keysize = 1.5,
          symkey = T,
          col = my_palette,
          cexRow=1,
          cexCol=1,
          margins = c(7,11),
          srtCol = 45)

# heatmap.2(as.matrix(cluster2.3genes),
#           distfun = corfun,
#           scale="row",
#           Colv = F,
#           dendrogram = "row",
#           trace = "none",
#           main = "Cluster 2.3 Heat Map",
#           keysize = 1.5,
#           symkey = T,
#           col = my_palette,
#           cexRow=1,
#           cexCol=1,
#           margins = c(7,11),
#           srtCol = 45)


heatmap.2(as.matrix(cluster3.1genes),
          distfun = corfun,
          scale="row",
          Colv = F,
          dendrogram = "row",
          trace = "none",
          main = "Cluster IL – 6 KO vs BALB/c 
          Group 1 Heat Map",
          keysize = 1.5,
          symkey = T,
          col = my_palette,
          cexRow=1,
          cexCol=1,
          margins = c(7,11),
          srtCol = 45)

heatmap.2(as.matrix(cluster3.2genes),
          distfun = corfun,
          scale="row",
          Colv = F,
          dendrogram = "row",
          trace = "none",
          main = "Cluster IL – 6 KO vs BALB/c 
          Group 2 Heat Map",
          keysize = 1.5,
          symkey = T,
          col = my_palette,
          cexRow=1,
          cexCol=1,
          margins = c(7,11),
          srtCol = 45)

# heatmap.2(as.matrix(cluster3.3genes),
#           distfun = corfun,
#           scale="row",
#           Colv = F,
#           dendrogram = "row",
#           trace = "none",
#           main = "Cluster 3.3 Heat Map",
#           keysize = 1.5,
#           symkey = T,
#           col = my_palette,
#           cexRow=1,
#           cexCol=1,
#           margins = c(7,11),
#           srtCol = 45)

```

# Gene Ontology Enrichment Analysis

Now that we constructed heat maps to visualize our gene expression data, we can begin our GO enrichment analysis. When given a set of genes that are up-regulated under certain conditions, an enrichment analysis will find which GO terms are over-represented (or under-represented) using annotations for that gene set.

To begin our GO Enrichment Analysis, we need to call the following libraries, 

```{r}
#BiocManager::install("org.Mm.eg.db")
library(Category)
library("annotate")
library("org.Mm.eg.db") #	Mus musculus database
library("GOstats")
library(GO.db)
```

Once the proper libraries are loaded, a hypergeometric test will be conducted to determine which genes are over represented using the `hyperGtest` function. The parameters for this function includes a gene ID vector, a gene universe vector, an annotation database, p value cutoff among other things. Because the function expects Entrez gene IDs and our dataset provides Ensembl IDs, we can convert them to Entrez IDs in order for this to work.

To convert Ensembl IDs to Entrez IDs, the `select` function was used. This was done for the gene IDs for each of our comparisons as well as the gene universe.

```{r}
ensemble2entre_gene_ids1 = select(org.Mm.eg.db,
                                  columns = "ENTREZID",
                                  keys = rownames(diffexp_norm_C57_KO),
                                  keytype = "ENSEMBL")

ensemble2entre_gene_ids2 = select(org.Mm.eg.db,
                                  columns = "ENTREZID",
                                  keys = rownames(diffexp_norm_C57_Balb),
                                  keytype = "ENSEMBL")


ensemble2entre_gene_ids3 = select(org.Mm.eg.db,
                                  columns = "ENTREZID", 
                                  keys = rownames(diffexp_norm_KO_Balb),
                                  keytype = "ENSEMBL")


ensemble2entre_univ = select(org.Mm.eg.db, 
                             columns = "ENTREZID", 
                             keys = rownames(normalizedcounts.matrix),
                             keytype = "ENSEMBL")

head(ensemble2entre_gene_ids1)



g1.1_id = select(org.Mm.eg.db,
                 columns = "ENTREZID",
                 keys = group1.1,
                 keytype = "ENSEMBL")
g1.2_id = select(org.Mm.eg.db,
                 columns = "ENTREZID",
                 keys = group1.2,
                 keytype = "ENSEMBL")
# g1.3_id = select(org.Mm.eg.db,
#                  columns = "ENTREZID",
#                  keys = group1.3,
#                  keytype = "ENSEMBL")
g2.1_id = select(org.Mm.eg.db,
                 columns = "ENTREZID",
                 keys = group2.1,
                 keytype = "ENSEMBL")
g2.2_id = select(org.Mm.eg.db,
                 columns = "ENTREZID",
                 keys = group2.2,
                 keytype = "ENSEMBL")
# g2.3_id = select(org.Mm.eg.db,
#                  columns = "ENTREZID",
#                  keys = group2.3,
#                  keytype = "ENSEMBL")
g3.1_id = select(org.Mm.eg.db,
                 columns = "ENTREZID",
                 keys = group3.1,
                 keytype = "ENSEMBL")
g3.2_id = select(org.Mm.eg.db,
                 columns = "ENTREZID",
                 keys = group3.2,
                 keytype = "ENSEMBL")
# g3.3_id = select(org.Mm.eg.db,
#                  columns = "ENTREZID",
#                  keys = group3.3,
#                  keytype = "ENSEMBL")


```

Now that our Ensembl Gene IDs are converted to EntrezIDs, we can begin defining our paramters for the `hyperGtest` function.
```{r}
param1 = new("GOHyperGParams",
            geneIds = ensemble2entre_gene_ids1$ENTREZID,
            universeGeneIds = ensemble2entre_univ$ENTREZID,
            annotation = "org.Mm.eg",
            ontology = "BP",
            pvalueCutoff = 0.001,
            conditional = T,
            testDirection = "over")

param2 = new("GOHyperGParams",
             geneIds = ensemble2entre_gene_ids2$ENTREZID,
             universeGeneIds = ensemble2entre_univ$ENTREZID,
             annotation = "org.Mm.eg.db",
             ontology = "BP",
             pvalueCutoff = 0.001,
             conditional = T,
             testDirection = "over")

param3 = new("GOHyperGParams",
             geneIds = ensemble2entre_gene_ids3$ENTREZID,
             universeGeneIds = ensemble2entre_univ$ENTREZID,
             annotation = "org.Mm.eg.db",
             ontology = "BP",
             pvalueCutoff = 0.001,
             conditional = T,
             testDirection = "over")
```


```{r}
group1.1param = new("GOHyperGParams",
             geneIds = g1.1_id$ENTREZID,
             universeGeneIds = ensemble2entre_univ$ENTREZID,
             annotation = "org.Mm.eg.db",
             ontology = "BP",
             pvalueCutoff = 0.001,
             conditional = T,
             testDirection = "over")
group1.2param = new("GOHyperGParams",
             geneIds = g1.2_id$ENTREZID,
             universeGeneIds = ensemble2entre_univ$ENTREZID,
             annotation = "org.Mm.eg.db",
             ontology = "BP",
             pvalueCutoff = 0.001,
             conditional = T,
             testDirection = "over")
# group1.3param = new("GOHyperGParams",
#              geneIds = g1.3_id$ENTREZID,
#              universeGeneIds = ensemble2entre_univ$ENTREZID,
#              annotation = "org.Mm.eg.db",
#              ontology = "BP",
#              pvalueCutoff = 0.001,
#              conditional = T,
#              testDirection = "over")
group2.1param = new("GOHyperGParams",
             geneIds = g2.1_id$ENTREZID,
             universeGeneIds = ensemble2entre_univ$ENTREZID,
             annotation = "org.Mm.eg.db",
             ontology = "BP",
             pvalueCutoff = 0.001,
             conditional = T,
             testDirection = "over")
group2.2param = new("GOHyperGParams",
             geneIds = g2.2_id$ENTREZID,
             universeGeneIds = ensemble2entre_univ$ENTREZID,
             annotation = "org.Mm.eg.db",
             ontology = "BP",
             pvalueCutoff = 0.001,
             conditional = T,
             testDirection = "over")
# group2.3param = new("GOHyperGParams",
#              geneIds = g2.3_id$ENTREZID,
#              universeGeneIds = ensemble2entre_univ$ENTREZID,
#              annotation = "org.Mm.eg.db",
#              ontology = "BP",
#              pvalueCutoff = 0.001,
#              conditional = T,
#              testDirection = "over")
group3.1param = new("GOHyperGParams",
             geneIds = g3.1_id$ENTREZID,
             universeGeneIds = ensemble2entre_univ$ENTREZID,
             annotation = "org.Mm.eg.db",
             ontology = "BP",
             pvalueCutoff = 0.001,
             conditional = T,
             testDirection = "over")
group3.2param = new("GOHyperGParams",
             geneIds = g3.2_id$ENTREZID,
             universeGeneIds = ensemble2entre_univ$ENTREZID,
             annotation = "org.Mm.eg.db",
             ontology = "BP",
             pvalueCutoff = 0.001,
             conditional = T,
             testDirection = "over")
# group3.3param = new("GOHyperGParams",
#              geneIds = g3.3_id$ENTREZID,
#              universeGeneIds = ensemble2entre_univ$ENTREZID,
#              annotation = "org.Mm.eg.db",
#              ontology = "BP",
#              pvalueCutoff = 0.001,
#              conditional = T,
#              testDirection = "over")


```

And since our parameters are ready, we can finally use the `hyperGtest` function to determine which genes are over expressed in each of the comparisons. 

```{r}
overRepresented1 = hyperGTest(param1)
head(summary(overRepresented1), n = 20)

overRepresented2 = hyperGTest(param2)
head(summary(overRepresented2), n = 20)

overRepresented3 = hyperGTest(param3)
head(summary(overRepresented3), n = 20)
```

The Go terms were gotten for each group of each cluster. It was thought that this could be more insightful.
```{r}

overRepresented1.1 = hyperGTest(group1.1param)
sum1.1 = summary(overRepresented1.1)
head(sum1.1$Term, n=20)

overRepresented1.2 = hyperGTest(group1.2param)
sum1.2 = summary(overRepresented1.2)
head(sum1.2$Term, n=20)

# overRepresented1.3 = hyperGTest(group1.3param)
# sum1.3 = summary(overRepresented1.3)
# head(sum1.3$Term, n=20)

overRepresented2.1 = hyperGTest(group2.1param)
sum2.1 = summary(overRepresented2.1)
head(sum2.1$Term, n=20)

overRepresented2.2 = hyperGTest(group2.2param)
sum2.2 = summary(overRepresented2.2)
head(sum2.2$Term, n=20)

# overRepresented2.3 = hyperGTest(group2.3param)
# sum2.3 = summary(overRepresented2.3)
# head(sum2.3$Term, n=20)

overRepresented3.1 = hyperGTest(group3.1param)
sum3.1 = summary(overRepresented3.1)
head(sum3.1$Term, n=20)

overRepresented3.2 = hyperGTest(group3.2param)
sum3.2 = summary(overRepresented3.2)
head(sum3.2$Term, n=20)

# overRepresented3.3 = hyperGTest(group3.3param)
# sum3.3 = summary(overRepresented3.3)
# head(sum3.3$Term, n=20)

```













